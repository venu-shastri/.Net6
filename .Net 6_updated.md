## .Net 6

- Single runtime for mobile, Web, IoT, games, and many other targets,.

  

![image-20220529151149467](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20220529151149467.png)

- Supported OS Versions
  - https://github.com/dotnet/core/blob/main/release-notes/6.0/supported-os.md
- Installation : [Download .NET 6.0 (Linux, macOS, and Windows) (microsoft.com)](https://dotnet.microsoft.com/en-us/download/dotnet/6.0)
- If you have Visual Studio 2022 installed, you might already have it up and running.
- By opening a Powershell prompt and typing the following command, we can determine what version of.NET we are currently running.
  - 

```
:> dotnet --version
```

- .NET 6 runs everywhere, from Windows to the Web, Linux, and mobile and embedded devices
- .NET 6 contains two default runtimes
  - Mono
    - Default runtime for running on a Non Windows-based operating system
  - CoreCLR
    - The CoreCLR is the .NET 6 version of the classic CLR
    - Common Language Runtime (desktop application, web application, or console app)used for running .NET code on Windows
  - WinRT 
    - Runtime used for Universal Windows Platform Applications, or UWP
    - UWP was created with the intention of allowing developers to "build once, run on all Windows 10 devices"(computers, tablets, smartphones, Xbox, Hololens, and embedded devices).
    - WinRT isn't a runtime in the traditional sense. It's more of a user interface for the Win32 API.
  - The .NET 6 runtimes are open source and available at  : https://github.com/dotnet/runtime.



### Execution Process

---

- Compile Source Code  to the Microsoft Intermediate Language, or MSIL
- Compile MSIL Code to Native Code 
  - Using the Just-In-Time, or JIT compiler
    - Compile on Demand during execution , store the compiled code and resuse
  - Using .NET’s ahead-of-time compiler called CoreRT
    -  Translation of the entire set of MSIL instructions into native code during program installation.
    - In .NET AOT compilation is handled by a tool called the native image generator, or Ngen



### Architecture

---

![image-20220529155524817](E:\.net 6\image-20220529155524817.png)



#### Target Framework Moniker (TFM)

----

```xml
setting the Target Framework Moniker or TFM to .NET 6 with Windows support and the UseWPF tag in the csproj file that adds support for WPF in a .NET 6 project.


Adding WPF support

<Project Sdk="Microsoft.NET.Sdk">
	<PropertyGroup>
		<OutputType>WinExe</OutputType>
		<TargetFramework>net6.0-windows</TargetFramework>
		<Nullable>enable</Nullable>
		<UseWPF>true</UseWPF>
	</PropertyGroup>
</Project>

Adding WinForms support

<Project Sdk="Microsoft.NET.Sdk">
	<PropertyGroup>
		<OutputType>WinExe</OutputType>
		<TargetFramework>net6.0-windows</TargetFramework>
		<UseWindowsForms>true</UseWindowsForms>
</Project>
```



##### NET 6 includes the following TFMs:

-  net6.0
- net6.0-Android
-  net6.0-ios
-  net6.0-macos
-  net6.0-maccatalyst
-  net6.0-tvos
-  net6.0-Windows



#### CLI

---

https://docs.microsoft.com/en-us/dotnet/core/tools/.

```
C:\Users\user>dotnet --version
6.0.300

C:\Users\user>dotnet new --list
These templates matched your input:

Template Name                                 Short Name           Language    Tags
--------------------------------------------  -------------------  ----------  --------------------------
ASP.NET Core Empty                            web                  [C#],F#     Web/Empty
ASP.NET Core gRPC Service                     grpc                 [C#]        Web/gRPC
ASP.NET Core Web API                          webapi               [C#],F#     Web/WebAPI
ASP.NET Core Web App                          webapp,razor         [C#]        Web/MVC/Razor Pages
ASP.NET Core Web App (Model-View-Controller)  mvc                  [C#],F#     Web/MVC
ASP.NET Core with Angular                     angular              [C#]        Web/MVC/SPA
ASP.NET Core with React.js                    react                [C#]        Web/MVC/SPA
ASP.NET Core with React.js and Redux          reactredux           [C#]        Web/MVC/SPA
Blazor Server App                             blazorserver         [C#]        Web/Blazor
Blazor WebAssembly App                        blazorwasm           [C#]        Web/Blazor/WebAssembly/PWA
Class Library                                 classlib             [C#],F#,VB  Common/Library
Console App                                   console              [C#],F#,VB  Common/Console
dotnet gitignore file                         gitignore                        Config
Dotnet local tool manifest file               tool-manifest                    Config
EditorConfig file                             editorconfig                     Config
global.json file                              globaljson                       Config
MSTest Test Project                           mstest               [C#],F#,VB  Test/MSTest
MVC ViewImports                               viewimports          [C#]        Web/ASP.NET
MVC ViewStart                                 viewstart            [C#]        Web/ASP.NET
NuGet Config                                  nugetconfig                      Config
NUnit 3 Test Item                             nunit-test           [C#],F#,VB  Test/NUnit
NUnit 3 Test Project                          nunit                [C#],F#,VB  Test/NUnit
Protocol Buffer File                          proto                            Web/gRPC
Razor Class Library                           razorclasslib        [C#]        Web/Razor/Library
Razor Component                               razorcomponent       [C#]        Web/ASP.NET
Razor Page                                    page                 [C#]        Web/ASP.NET
Solution File                                 sln                              Solution
Web Config                                    webconfig                        Config
Windows Forms App                             winforms             [C#],VB     Common/WinForms
Windows Forms Class Library                   winformslib          [C#],VB     Common/WinForms
Windows Forms Control Library                 winformscontrollib   [C#],VB     Common/WinForms
Worker Service                                worker               [C#],F#     Common/Worker/Web
WPF Application                               wpf                  [C#],VB     Common/WPF
WPF Class Library                             wpflib               [C#],VB     Common/WPF
WPF Custom Control Library                    wpfcustomcontrollib  [C#],VB     Common/WPF
WPF User Control Library                      wpfusercontrollib    [C#],VB     Common/WPF
xUnit Test Project                            xunit                [C#],F#,VB  Test/xUnit

```



### C# 6.0 Features



### Nullable Types

---

- A nullable type is denoted with a value type followed by the ? symbol:
- T? translates into System.Nullable<T>. Nullable<T> is a lightweight immutable structure, having only two fields, to represent Value and HasValue

```C#
int? i = null; // OK, Nullable Type
Console.WriteLine (i == null); // True


translates to:
Nullable<int> i = new Nullable<int>();
Console.WriteLine (! i.HasValue); // True


The conversion from T to T? is implicit, and from T? to T is explicit. For example:
int? x = 5; // implicit
int y = (int)x; // explicit

C# also permits the unboxing of nullable types with the as operator. The result will be null if the cast fails:
object o = "string";
int? x = o as int?;
Console.WriteLine (x.HasValue); // False
```



#### Null Coalescing Operator

---

- The ?? operator is the null coalescing operator, and it can be used with both nullable types and reference types.

- It says “If the operand is non-null, give it to me; otherwise, give me a default value.

- The null-coalescing operator `??` returns the value of its left-hand operand if it is not a `null` value. If it is null, then it evaluates the right-hand operand and returns its result.

  

```C#
int? x = null;
int y = x ?? 5; // y is 5
int? a = null, b = 1, c = 2;
Console.WriteLine (a ?? b ?? c); // 1 (first non-null value)
```

#### Caller Info Attributes

---

- [CallerMemberName] applies the caller’s member name
-  [CallerFilePath] applies the path to caller’s source code file
-  [CallerLineNumber] applies the line number in caller’s source code file

```C#
using System;
using System.Runtime.CompilerServices;
class Program
{
	static void Main()
	{
		Foo();
	}
static void Foo ([CallerMemberName] string z = null,[CallerFilePath] string filePath = null,
[CallerLineNumber] int lineNumber = 0)
	{
		Console.WriteLine (memberName);
		Console.WriteLine (filePath);
		Console.WriteLine (lineNumber);
	}
```



#### **Auto-property initializers**

---

```C#
public class Patient
{

    public string MRB { get; } = "MRN"+GUID.NewId();

    public DateTime RegistrationDate { get; } = DateTime.Today;

}

```

#### **Expression Bodied Methods and Auto-Properties**

---

```C#
public TimeSpan Age => DateTime.Now – DateOfBirth;
public override string ToString() => string.Format("{0} is {1} ", MRN, Age);
```

#### **Dictionary initializers**

```
var patientDict = new Dictionary<string, Patient>;
{
	["MRN1"] = new Person("Tom", 28),
	["MRN2"] = new Person("Hary", 25)
};
```

#### Null-Conditional Operator

---



```C#
if (patientList != null)
{
	Patient first = patientList[0];
	int count = patinetList.Count;            
}

//New Syntax
Patient first = patientList?[0];  // null if patientList is null
int? nullableCount = patientList?.Count; // null if patientList is null
int count = personList?.Count ?? 0; // 0 if patientList is null

int length = patient?.Name?.Length ?? 0; 
```



####  String Interpolation

---

```C#
string.Format("Patient MRN :{0} {1} , Name:{2} and Age is:{3}.", MRN, Name,  Age);

string message= $"Patient MRN :{MRN}, Name:{Name} and Age is:{Age}.";


```



#### Using Static

-----

```c#
using static System.Console;
...

...
static void Main(){
 WriteLine("Hello.............");
}

```



#### **The nameof Operator**

----

```C#
operator nameof returns the name of any item like class, method, property or parameter.

public class Patient
{

    public string MRB { get; } = "MRN"+GUID.NewId();

    public DateTime RegistrationDate { get; } = DateTime.Today;

}

static void Main(){
    
    Console.WriteLine(nameof(Patient));
}

```

#### Exception Filters

---

```C#
try
{
	throw new Exception("Test exception");
}
catch (Exception ex) when (ex.Message == "Test exception")
{
	Console.WriteLine("Test exception caught");
}
catch (Exception ex) 
{
	Console.WriteLine("Other exception caught here");
}
```



### C# 7.0 Features

---

#### Out Variables

- The ability to declare a variable right at the point where it is passed as an out argument
- Caller Can Ignore Out Variable using _ (discard ) operator

```C#
public static void Main()
	{
		//out variables
		Console.WriteLine("Hello World");
		string data="1234";
		//preDeclare variable
		//int targetValue;
		ConvertToInt(data,out int targetValue,out int code); // C# 7.0
		ConvertToInt(data,out var _targetValue,out _); //Discard
	}
public static bool ConvertToInt(string input,out int convertedValue,out int code){
		
		convertedValue=0;
		code=0;
		return true;
	}
```



#### Pattern matching

---

- Instead of just a type, is expressions can now have a pattern on the right hand side.
- Switch statement case clauses can now match on patterns rather than just constant values.

```C#
sttaic void Main(){
object obj=GetObject();
		if(obj is null){
			Console.WriteLine("Obj is Null");
		}
		
		else if(obj is Program){
			Console.WriteLine("Obj is of Type Program");
		}
		else if(obj is int x){
			//int x=(int)obj;
			Console.WriteLine($"Obj is of Type Integer and value is {x}" );
		}
		
		/* Is Expressions with Patterns - C# 7.0
		if(obj is int i || obj is string s && .......
		*/
}

	public static void Deploy(Environment env){
		switch(env.Name){
				
			case string s when(s == "Test"):Console.WriteLine($"Test Env Deploy" );break;
			
		}
		
		//_depolyStatergies[env.Name].Invoke();
		
		
	}


static void IfElsePatternMatching()
{
  Console.WriteLine("===If Else Pattern Matching ===/n");
  object testItem1 = 123;
  object testItem2 = "Hello";
  if (testItem1 is string myStringValue1)
  {
    Console.WriteLine(&"{myStringValue1} is a string");
  }
  if (testItem1 is int myValue1)
  {
    Console.WriteLine(&"{myValue1} is an int");
  }
  if (testItem2 is string myStringValue2)
  {
   Console.WriteLine(&"{myStringValue2} is a string");
  }
  if (testItem2 is int myValue2)
  {
   Console.WriteLine(&"{myValue2} is an int");
  }
  Console.WriteLine();

}
```



#### **tuple types and **tuple literals:

---

- A tuple is **a data structure that contains a sequence of elements of different data types**. It can be used where you want to have a data structure to hold an object with properties, but you don't want to create a separate type for it

```C#
(string, string, string) FindPatientName(string  mrn) // tuple return type
{
    ... // retrieve first, middle and last from data storage
    return (first, middle, last); // tuple literal
}

var names = FindPatientName(id);
WriteLine($"found {names.Item1},{names.Item2}, {names.Item3}.");

//Descriptive Items
(string first, string middle, string last) FindPatientName(string mrn) // tuple elements have names
....
var names = FindPatientName(id);
WriteLine($"found {names.first},{names.middle}, {names.last}.");

.....
specify element names directly in tuple literals:

return (first: first, middle: middle, last: last); // named tuple elements in a literal


```



#### Deconstruction

---

- A deconstructing declaration is a syntax for breaking down a tuple (or other value) into its constituent pieces and assigning each portion to a new variable:

  

```
(string first, string middle, string last) = FindPatientName(mrn); // deconstructing declaration
(var first, var middle, var last) = LookupName(id1); // var inside
var (first, middle, last) = LookupName(id1); // var outside

```

#### Deconstructor

---

```C#
class Patient
{
    public string  MRN { get; }
    public string  Name { get; }

    public Point(string  mrn,string  name) { MRN = mrn; Name =name; }
    public void Deconstruct(out string mrn, out  string name) { mrn = MRN; name = Name; }
}


....

(var mrn,var name )= new Patient("MRN100","Tom");

.."discards" in deconstruction....
(var mrn,_ )= new Patient("MRN100","Tom");
```



#### Throw expressions

---

```C#
class Patient
{
    public string MRN { get; }
    
    public Person(string mrn) => MRN = mrn ?? throw new ArgumentNullException(nameof(name));
    
    public string GetName() => throw new NotImplementedException();
}
```



#### Local functions

---



```C#
//Closure Using Local Functions

public static Func<string,bool> CheckStringStartsWithAnyPatterns(string pattern){

      //local Function
      bool Predicate(string item){
      return item.Startswith(pattern);
      }
      
      return Predicate;

}
```

#### ***Digit Separator\***

---

```
//Literal Improvements
var accountNumber = 123_456;

```



#### Ref returns and locals

---

```C#
//ref returns 
	static ref int searchNumber(int[] source,int number){
		
		for(int i=0;i<source.Length;i++){
			if(source[i]==number){
				
				return ref source[i];//value type
			}
		}
		throw new Exception("Element Not Foud");
	}
	
	public static void Main()
	{
		int[] numbers={1,2,345,5,9,7,8};
		ref int result=ref searchNumber(numbers,345);//result->pointer->numbers[2]
		Console.WriteLine("Result : "+result);
		result=1000;
		Console.WriteLine("Change in Result : "+result);
		for(int i=0;i<numbers.Length;i++){
			Console.WriteLine(numbers[i]);
		}
		
	}
```



### private protected member

---

- The `private protected` keyword combination is a member access modifier. A private protected member is accessible by types derived from the containing class, but only within its containing assembly.

```C#
//Assembly AB.dll
public class A
{
    private protected int member= 0;
}

public class B : A
{
    void Access()
    {
        // OK, accessed through the current derived class instance
        member = 5;
    }
}
....
A obj=new A();
obj.member=10; //Error


//Assembly XY.dll
// Compile with: /reference:AB.dll

class C : A
{
    void Access()
    {
        // Error CS0122, because myValue can only be
        // accessed by types in Assembly1
        // member = 10;
    }
}
```



#### Non trailing Named Arguments

```
private static void PrintPatientInfo(string mrn,string name, int age, string address, bool isInsured = default, bool isEmployee = default)
{
    Console.WriteLine("Mrn: {0}, Name: {1}, Age: {2}, Address: {3}, Is Insured: {4}, Is Employee: {5}", mrn,name, age, address, isInsured, isEmployee);
}

public static void Example()
{
    PrintPatientInfo("MRN100",Tom", 24, "BLR");
    PrintPatientInfo("MRN200",John", 31, "CHN", true, false);
    PrintPatientInfo(mrn:"MRN300",name:"Stella", age:29, address:"HYD", isInsured:true, isEmployee:true);
    PrintPatientInfo(mrn:"M400",age:27, address:"BLR", name: "Andy", isEmployee: true, isInsured: true);
}

//Before C# 7.2, it was not allowed to specify the named arguments before positional arguments.
```



### C# 8.0 Features

---

#### Nullable Reference Types

---

- Non-nullability to reference types helps to avoid  NullReferenceExceptions
- Nullable reference types introduce a level of safety that’s enforced purely by the compiler, in the form of warnings when it detects code that’s at risk of generating a NullReferenceException
- Enabling nullable reference types 
  -  #nullable enable directive 
  - <Nullable>enable</Nullable> project setting) 
- It enables the nullable annotation context, which tells the compiler to treat all reference-type variable declarations as non-nullable unless suffixed by the ? symbol.
  • It enables the nullable warning context, which tells the compiler to generate warnings upon encountering code at risk of throwing a NullReferenceException.
- 

```c#
To enable nullable reference types, add the Nullable element to  .csproj project file (if you want to enable it for the entire project):
<PropertyGroup>
<Nullable>enable</Nullable>
</PropertyGroup>


...Code....
#nullable enable // enables nullable reference types from this point on
#nullable disable // disables nullable reference types from this point on
#nullable restore // resets nullable reference types to project setting

#nullable enable // Enable nullable reference types
string s1 = null; // Generates a compiler warning!
string? s2 = null; // OK: s2 is nullable reference type


#nullable disable
string reverse(string s)
{
    return s.ToUpper();
}

Console.WriteLine(reverse(null));

....AOP......
using System.Diagnostics.CodeAnalysis;

PassNullUsingAttribute(null, null);

void PassNullUsingAttribute([AllowNull] string msg, [DisallowNull] string content) { 

}
```

##### Null-forgiving operator (!)

```
void Foo (string? s) => Console.Write (s.Length); //warning generated

void Foo(string? s) => Console.Write(s!.Length);
```

##### Treating Nullable Warnings as Errors

```xml
<PropertyGroup>
<Nullable>enable</Nullable>
<WarningsAsErrors>CS8600;CS8602;CS8603</WarningsAsErrors>
</PropertyGroup>
```

##### Attributes for null-state static analysis

---

https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/nullable-analysis



### Readonly Instance Members

---



```C#
//Source - https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/readonly-instance-members
public struct Vector2
{
    public float x;
    public float y;

    public readonly float GetLengthReadonly()
    {
        return MathF.Sqrt(LengthSquared);
    }

    public float GetLength()
    {
       
        return MathF.Sqrt(LengthSquared);
    }

    public readonly float GetLengthIllegal()
    {
        var tmp = MathF.Sqrt(LengthSquared);

        x = tmp;    // Compiler error, cannot write x
        y = tmp;    // Compiler error, cannot write y

        return tmp;
    }

    public readonly float LengthSquared
    {
        get
        {
            return (x * x) +
                   (y * y);
        }
    }
}

public static class MyClass
{
    public static float ExistingBehavior(in Vector2 vector)
    {
        // This code causes a hidden copy, the compiler effectively emits:
        //    var tmpVector = vector;
        //    return tmpVector.GetLength();
        //
        // This is done because the compiler doesn't know that `GetLength()`
        // won't mutate `vector`.

        return vector.GetLength();
    }

    public static float ReadonlyBehavior(in Vector2 vector)
    {
        // This code is emitted exactly as listed. There are no hidden
        // copies as the `readonly` modifier indicates that the method
        // won't mutate `vector`.

        return vector.GetLengthReadonly();
    }
}
```



#### default interface methods

---

- *virtual extension methods*  - methods in interfaces with concrete implementations.
- Default interface methods enable an API author to add methods to an interface in future versions without breaking source or binary compatibility with existing implementations of that interface.
- Adding default interface implementations provides the elements of the "traits" language feature

```c#
//Source: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods
interface IA
{
    void M() { WriteLine("IA.M"); }
}

class A:IA{

    static void Main(){
	A obj=new A();
	obj.M();
        
    }
}



interface IB : IA
{
    void IA.M() { WriteLine("IB.M"); } // Explicit implementation
}
interface IC : IA
{
    void M() { WriteLine("IB.M"); } // Creates a new M, unrelated to `IA.M`. Warning
}

interface ILogger
{
void Log (string text) => Console.WriteLine (Prefix + text);
static string Prefix = ""; //supports static variable
    
}

ILogger.Prefix = "File log: ";
```

##### Reabstraction

```C#
interface IA
{
    void M() { WriteLine("IA.M"); }
}
interface IB : IA
{
    abstract void IA.M();
}
class C : IB { } // error: class 'C' does not implement 'IA.M'.
```

#### using declarations

---

- The lifetime of a `using` local will extend to the end of the scope in which it is declared

```C#
if (...) 
{ 
   using FileStream f = new FileStream(@"C:\users\jaredpar\using.md");
   // statements
}

// Equivalent to 
if (...) 
{ 
   using (FileStream f = new FileStream(@"C:\users\jaredpar\using.md")) 
   {
    // statements
   }

    
    
```

#### static local functions

---

- Support local functions that disallow capturing state from the enclosing scope.
- Locals, parameters, and `this` from the enclosing scope are not available within a `static` local function
- https://github.com/dotnet/csharplang/blob/master/meetings/2018/LDM-2018-09-10.md#static-local-functions

####  Indices and ranges

---

- Indices and ranges are a simple way to access single items or ranges of elements in a sequence.

- In C# 8.0, the following two new types are added.

  - Range

    - The `System.Range` struct represents a range that has start and end indexes.
    - The range operator `..`, which specifies the start and end of a range as its operands.
    - The start of the range is inclusive, but the end of the range is exclusive, meaning the start is included in the range but the end isn't.
    - Ranges let you “slice” an array by using the .. operator

    

  - Index

    - The `System.Index` struct represents a type that can be used to index a collection either from the start or the end.
    - The `^` operator specifies the relative index from the end of an array.

  

```c#
string[] nameOfMonths = { 
                          // index from start    index from end
    "January",            // 0                   ^12
    "February",           // 1                   ^11
    "March",              // 2                   ^10
    "April",              // 3                   ^9
    "May",                // 4                   ^8
    "June",               // 5                   ^7
    "July",               // 6                   ^6
    "August",             // 7                   ^5
    "September",          // 8                   ^4
    "October",            // 9                   ^3
    "November",           // 10                  ^2
    "December"            // 11                  ^1
                          // 12 (nameOfMonths.Length)  ^0
};

List<char> list = ...;
var value = list[^1];

// Gets translated to
var value = list[list.Count - 1];

var names = nameOfMonths[2..5];

foreach (var name in names)
{
    Console.WriteLine(name);
}

Range phrase = 1..3;
Range phrase = ^2..^0;
var names = nameOfMonths[phrase];

var allMonths = nameOfMonths[..];       // contains all names.
var firstTwoMonths = nameOfMonths[..2]; // contains first two names i.e. January and February.
var lastThreeMonths = nameOfMonths[9..];     // contains the last three names.


char[] vowels = new char[] {'a','e','i','o','u'};
char lastElement = vowels [^1]; // 'u'
char secondToLast = vowels [^2]; // 'o'

char[] firstTwo = vowels [..2]; // 'a', 'e'
char[] lastThree = vowels [2..]; // 'i', 'o', 'u'
char[] middleOne = vowels [2..3] // 'i'
char[] lastTwo = vowels [^2..]; // 'o', 'u'
```



#### Null-coalescing Assignment

---

- A new null-coalescing assignment operator `??=` assigns the value of its right-hand operand to its left-hand operand only if the left-hand operand evaluates to null.

- The ??= operator assigns a variable only if it’s null.

  

```C#
 Instead of this:
if (s == null) s = "Hello, world";
you can now write this:
s ??= "Hello, world";

List<int> numList = null;
numList ??= new List<int>() { 34, 71};

Console.WriteLine(string.Join(" ", numList));  // output: 34 71

int? val = null;
numList.Add(val ??= 120);

Console.WriteLine(string.Join(" ", numList));  // output: 34 71 120
Console.WriteLine(val);                        // output: 120
```



#### Switch Expressions

---

```C#
string cardName = cardNumber switch // assuming cardNumber is an int
{
	13 => "King",
	12 => "Queen",
	11 => "Jack",
	_ => "Pip card" // equivalent to 'default'
};

int cardNumber = 12; string suite = "spades";
	string cardName = (cardNumber, suite) switch
	{
		(13, "spades") => "King of spades",
		(13, "clubs") => "King of clubs",
	...
	};
	
	if (obj is string { Length:4 }) ...


```



#### Async Streams

---

- iterate a collection asynchronously

```
private static async IAsyncEnumerable<int> GenerateEvenSequence()
{
    for (int i = 0; i <= 50; i = i + 2)
    {
        await Task.Delay(100);
        yield return i;
    }
}

public static async Task PrintEvenSequenceAsync()
{
    await foreach (var number in GenerateEvenSequence())
    {
        Console.WriteLine(number);
    }
}
```

#### StackAlloc  in nested expressions

---

- The `stackalloc` operator allocates a memory block in the stack. A memory block is created during the execution of the method, and it is automatically deleted when the method is returned.



### C# 9.0

----

#### Top Level Statements

---

- Eliminate the need for much of the ceremony around the C# application’s entry point

- The class (Program) and Main() methods can be removed

  

```C#
using System;

// Display a simple message to the user.
Console.WriteLine("*****Top Level Statements *****");

// Wait for Enter key to be pressed before shutting down.
Console.ReadLine();

//MSIL Code
TypeDef #1 (02000002)
TypDefName: <Program>$  (02000002)
Flags     : [NotPublic] [AutoLayout] [Class] [Abstract] [Sealed] [AnsiClass] [BeforeFieldInit]  (00100180)
Extends   : 0100000D [TypeRef] System.Object
Method #1 (06000001) [ENTRYPOINT]
MethodName: <Main>$ (06000001)
```

- Rules around using top-level statements
  - Only one file in the application can use top-level statements.
  - When using top-level statements, the program cannot have a declared entry point.
  - The top-level statements cannot be enclosed in a namespace.
  - Top-level statements still access a string array of args.
  - Top-level statements return an application code by using a return.
  - Functions that would have been declared in the Program class become local functions for the top-level statements. 
  - Additional types can be declared after all top-level statements. Any types declared before the end of the top-level statements will result in a compilation error

####  Pattern matching enhancements

----

| Pattern                   | Meaning                                                      |
| ------------------------- | ------------------------------------------------------------ |
| Type patterns             | Checks if a variable is a type                               |
| Parenthesized patterns    | Enforces or emphasizes the precedence of pattern combinations |
| Conjuctive (and) patterns | Requires both patterns to match                              |
| Disjunctive (or) patterns | Requires either pattern to match                             |
| Negated (not) patterns    | Requires a pattern does not match                            |
| Relational patterns       | Requires input to be less than, less than or equal, greater than, or greater than or equal |

```C#

static void PatternMatchingUpdates()
{
    object testItem1 = 123;
    Type t = typeof(string);
    char c = 'f';


    //Type patterns
    if (t is Type)
    {
        Console.WriteLine($"{t} is a Type");
    }
    
    //Relational, Conjuctive, and Disjunctive patterns
    if (c is >= 'a' and <= 'z' or >= 'A' and <= 'Z')
    {
        Console.WriteLine($"{c} is a character");
    };

    //Parenthesized patterns
    if (c is (>= 'a' and <= 'z') or (>= 'A' and <= 'Z') or '.' or ',')
	{
    	Console.WriteLine($"{c} is a character or separator");
	};

    //Negative patterns
	if (testItem1 is not string)
	{
    	Console.WriteLine($"{testItem1} is not a string");
    }

    if (testItem1 is not null)
    {
	    Console.WriteLine($"{testItem1} is not null");
	}
}
    
```



#### init only setters

---

- Properties and indexers can be set at the point of object creation but become effectively `get` only once object creation has completed. 
- Ease of use and immutability

```C#
class Patient
{
    public string MRN { get; init; }
    public string Name { get; init; }
}

var p = new Patient()
{
    MRN = "M100"
    Name = "Tom",
};
p.MRN = "M200"; // Error: MRN is not settable
```



#### record

---

- `record` keyword to define a reference type that provides built-in functionality for encapsulating data.
- **Init-only properties** allow us to create immutable record types using object initialization.
- Using **positional records** we can completely eliminate init-only properties from the record declaration
-  **record type overrides both the virtual ToString and Equals methods** on the `Object` base class
- Non-destructive mutation allows the creation of new record instances from existing immutable records. 
- Benefits over class
  - Positional syntax for creating a reference type with immutable properties
  - Built-in formatting for display
  - Value-based equality
  - Non-destructive mutation with a concise syntax
  - Support for inheritance hierarchies
  - Built in Deconstructors support

##### Positional Records

```C#
record Person(string Name, int Age) { }
class Program
{
    static void Main(string[] args)
    {
        var person = new Person("Tom", 18);
        Console.WriteLine($"Name: {person.Name}, Age: {person.Age}");
        person.Age=34; //Error
    }
}


```

##### Record Type Overrides ToString Method

```C#
record Person(string Name, int Age) { }

class Program
{
    static void Main(string[] args)
    {
        var person = new Person("Tom", 18);

        Console.WriteLine(person.ToString());
    }
}

// Output
Person { Name = Tom, Age = 18 }
```

##### Record uses Value-based Equality

- The new record type uses it's property values to determine if records are equal and not if they are pointing to the same memory location / instance

```C#
ecord Person(string Name, int Age) { }

class Program
{
    static void Main(string[] args)
    {
        var person1 = new Person("Tom", 18);

        var person2 = new Person("Tom", 18);

        if (person1 == person2)
           Console.WriteLine("They are equivalent.");
    }
}

// Output
They are equivalent.
```

##### Record Type and With-expression

- Create a new record based on an existing record with some minor changes

  

```C#
record Person(string Name, int Age) { }

class Program
{
    static void Main(string[] args)
    {
        var person = new Person("Tom", 18);

        var person2 = person with { Name = "Hary" };

        Console.WriteLine(person2.ToString());
    }
}

// Output
Person { Name = Hary, Age = 18 }
```

##### Inheritance

```C#
public record Person(string Name, int Age);
public record Employee(string Name, int Age, string Eid): Person(Name, Age);
var emp = new Employee("Tom", 47, “E1000”);
```

##### Using Deconstructors

```C#
record Person(string Name, int Age) { }
record Employee(string Eid,string Name, int Age) : Person(Name, Age) { }

var emp = new Employee("E100","Tom",34);
var (Eid, Name,Age) = emp;
Console.WriteLine($"{Eid} {Name} {Age}");



```

##### Native-sized integers

---

- `nint` and `nuint` keywords to define *native-sized integers*. These are 32-bit integers when running in a 32-bit process, or 64-bit integers when running in a 64-bit process
- Used for interop scenarios, low-level libraries, and to optimize performance in scenarios where integer math is used extensively

```C#
using static System.Console;
nint x = 3;
int y = 3;
long v = 10;

WriteLine($"nint.MinValue = {nint.MinValue}");
WriteLine($"nint.MaxValue = {nint.MaxValue}");
WriteLine($"nuint.MinValue = {nuint.MinValue}");
WriteLine($"nuint.MaxValue = {nuint.MaxValue}");

WriteLine(nint.Equals(x, y)); // False
WriteLine(nint.Equals(x, (nint)y)); // True

var test1 = y + 1 > x; // True;
WriteLine(test1);
var test2 = y - 1 == x; // False
WriteLine(test2);

var test3 = typeof(nint); // System.IntPtr
WriteLine(test3);
var test4 = typeof(nuint); // System.UIntPtr
WriteLine(test4);
var test5 = (x + 1).GetType(); // System.IntPtr
WriteLine(test5);
var test6 = (x + y).GetType(); // System.IntPtr
WriteLine(test6);
var test7 = (x + v).GetType(); // System.Int64
WriteLine(test7);

dynamic z = 1;
var test8 = z + x; // RuntimeBinderException: '+' cannot be applied 'System.Int' and 'System.IntPtr'

string[] names = { };

string item=names[x];

List<string> nameList=names.ToList();
item=nameList[x]; //Error
```

##### Function Pointers

---

- https://github.com/dotnet/csharplang/issues/191

```C#

  unsafe  void Example(Action<int> a, delegate*<int, void> f) {
        a(42);
        f(42);
    }

```

##### Target Typed New Expression

---

```
var patient = new Patient("MRN100", "Tom");
```

> In  the `new` expression – that’s the part on the right side of the `=` sign – always requires the class name. That’s not the case anymore with C# 9.0 if the target-type is already known from the left side of the `=` sign, which is always the case if you don’t use the `var` keyword on the left side of the `=` sign.

```
Patient patient = new("MRN100", "Tom");
var patient=new("MRN100", "Tom"); //Error

public ObservableCollection<Patient> Patients { get; } = new();
```

######  Before

```C#
public class PatientViewModel
{
    public PatientViewModel()
    {
        AddPatientCommand = new DelegateCommand(AddPatientExecute);
        Patients = new ObservableCollection<Patient>();
    }

    public DelegateCommand AddPatientCommand { get; }

    public ObservableCollection<Patient> Patients { get; }

    private void AddPatientExecute()
    {
        Patients.Add(new Patient());
    }
}
```

##### Using Target Typed Expression

```C#
public class PatientViewModel
{
    public PatientViewModel()
    {
        AddPatientCommand = new (AddPatientExecute);
        Patients = new();
    }

    public DelegateCommand AddPatientCommand { get; }

    public ObservableCollection<Patient> Patients { get; }

    private void AddPatientExecute()
    {
        Patients.Add(new());
    }
}
```

##### Static Anonymous Functions

---

- Anonymous method are not cheap
  - https://devblogs.microsoft.com/premier-developer/dissecting-the-local-functions-in-c-7/#use-case-5-when-allocations-matters
  - *Overhead of a delegate invocation (very very small, but it does exist).*
  - ***2 heap allocations** if a lambda captures local variable or argument of enclosing method (one for closure instance and another one for a delegate itself).*
  - ***1 heap allocation** if a lambda captures an enclosing instance state (just a delegate allocation).*
  - ***0 heap allocations** only if a lambda does not capture anything or captures a static state.*
- A lambda or anonymous method may have a **static** modifier. The **static** modifier indicates that the lambda or anonymous method is a *static anonymous function*.
- A *static anonymous function* cannot capture state from the enclosing scope. As a result, locals, parameters, and **this** from the enclosing scope are not available within a *static anonymous function*.
- A *static anonymous function* cannot reference instance members from an implicit or explicit **this** or **base** reference.
- A *static anonymous function* may reference **static** members from the enclosing scope.
- A *static anonymous function* may reference **constant** definitions from the enclosing scope.

```
(static item) => {.........} 
```

##### Covariant  return types

---

- Covariance  - When a programming language let’s you express that more specific return type, this is called covariance

```C#
var developer = new Developer { FirstName = "Thomas" };
DeveloperSkills skills = developer.GetSkills();
Console.WriteLine($"Email: {skills.CanSendEmails}");
Console.WriteLine($".NET: {skills.KnowsDotNet}");

public class EmployeeSkills
{
    public bool CanSendEmails { get; set; }
}

public class DeveloperSkills : EmployeeSkills
{
    public bool KnowsDotNet { get; set; }
}

public class Employee
{
    public string? FirstName { get; set; }
    public virtual EmployeeSkills GetSkills()
    {
        return new EmployeeSkills
        {
            CanSendEmails = true
        };
    }
}

public class Developer : Employee
{
    public override DeveloperSkills GetSkills()
    {
        return new DeveloperSkills
        {
            CanSendEmails = true,
            KnowsDotNet = true
        };
    }
}
```

> Specifically, permit the override of a method to declare a more derived return type than the method it overrides, and similarly to permit the override of a read-only property to declare a more derived type - Microsoft